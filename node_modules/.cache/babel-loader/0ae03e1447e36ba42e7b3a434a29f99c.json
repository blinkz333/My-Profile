{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Vector = void 0;\n\nclass Vector {\n  constructor(x, y) {\n    let defX, defY;\n\n    if (y === undefined) {\n      if (typeof x === \"number\") {\n        throw new Error(\"tsParticles - Vector not initialized correctly\");\n      }\n\n      const coords = x;\n      [defX, defY] = [coords.x, coords.y];\n    } else {\n      [defX, defY] = [x, y];\n    }\n\n    this.x = defX;\n    this.y = defY;\n  }\n\n  static clone(source) {\n    return Vector.create(source.x, source.y);\n  }\n\n  static create(x, y) {\n    return new Vector(x, y);\n  }\n\n  static get origin() {\n    return Vector.create(0, 0);\n  }\n\n  get angle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n  set angle(angle) {\n    this.updateFromAngle(angle, this.length);\n  }\n\n  get length() {\n    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n  }\n\n  set length(length) {\n    this.updateFromAngle(this.angle, length);\n  }\n\n  add(v) {\n    return Vector.create(this.x + v.x, this.y + v.y);\n  }\n\n  addTo(v) {\n    this.x += v.x;\n    this.y += v.y;\n  }\n\n  sub(v) {\n    return Vector.create(this.x - v.x, this.y - v.y);\n  }\n\n  subFrom(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n  }\n\n  mult(n) {\n    return Vector.create(this.x * n, this.y * n);\n  }\n\n  multTo(n) {\n    this.x *= n;\n    this.y *= n;\n  }\n\n  div(n) {\n    return Vector.create(this.x / n, this.y / n);\n  }\n\n  divTo(n) {\n    this.x /= n;\n    this.y /= n;\n  }\n\n  distanceTo(v) {\n    return this.sub(v).length;\n  }\n\n  getLengthSq() {\n    return Math.pow(this.x, 2) + Math.pow(this.y, 2);\n  }\n\n  distanceToSq(v) {\n    return this.sub(v).getLengthSq();\n  }\n\n  manhattanDistanceTo(v) {\n    return Math.abs(v.x - this.x) + Math.abs(v.y - this.y);\n  }\n\n  copy() {\n    return Vector.clone(this);\n  }\n\n  setTo(velocity) {\n    this.x = velocity.x;\n    this.y = velocity.y;\n  }\n\n  rotate(angle) {\n    return Vector.create(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));\n  }\n\n  updateFromAngle(angle, length) {\n    this.x = Math.cos(angle) * length;\n    this.y = Math.sin(angle) * length;\n  }\n\n}\n\nexports.Vector = Vector;","map":null,"metadata":{},"sourceType":"script"}