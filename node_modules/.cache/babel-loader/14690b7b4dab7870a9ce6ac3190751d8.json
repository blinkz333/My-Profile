{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LinkInstance = void 0;\n\nconst Utils_1 = require(\"../../../Utils\");\n\nclass LinkInstance {\n  constructor(container) {\n    this.container = container;\n  }\n\n  particleCreated(particle) {\n    const linkParticle = particle;\n    linkParticle.links = [];\n  }\n\n  particleDestroyed(particle) {\n    const linkParticle = particle;\n    linkParticle.links = [];\n  }\n\n  drawParticle(context, particle) {\n    const linkParticle = particle;\n    const container = this.container;\n    const particles = container.particles;\n    const pOptions = particle.options;\n\n    if (linkParticle.links.length > 0) {\n      context.save();\n      const p1Links = linkParticle.links.filter(l => {\n        const linkFreq = container.particles.getLinkFrequency(linkParticle, l.destination);\n        return linkFreq <= pOptions.links.frequency;\n      });\n\n      for (const link of p1Links) {\n        const p2 = link.destination;\n\n        if (pOptions.links.triangles.enable) {\n          const links = p1Links.map(l => l.destination);\n          const vertices = p2.links.filter(t => {\n            const linkFreq = container.particles.getLinkFrequency(p2, t.destination);\n            return linkFreq <= p2.options.links.frequency && links.indexOf(t.destination) >= 0;\n          });\n\n          if (vertices.length) {\n            for (const vertex of vertices) {\n              const p3 = vertex.destination;\n              const triangleFreq = particles.getTriangleFrequency(linkParticle, p2, p3);\n\n              if (triangleFreq > pOptions.links.triangles.frequency) {\n                continue;\n              }\n\n              this.drawLinkTriangle(linkParticle, link, vertex);\n            }\n          }\n        }\n\n        if (link.opacity > 0 && container.retina.linksWidth > 0) {\n          this.drawLinkLine(linkParticle, link);\n        }\n      }\n\n      context.restore();\n    }\n  }\n\n  drawLinkTriangle(p1, link1, link2) {\n    var _a;\n\n    const container = this.container;\n    const options = container.actualOptions;\n    const p2 = link1.destination;\n    const p3 = link2.destination;\n    const triangleOptions = p1.options.links.triangles;\n    const opacityTriangle = (_a = triangleOptions.opacity) !== null && _a !== void 0 ? _a : (link1.opacity + link2.opacity) / 2;\n\n    if (opacityTriangle <= 0) {\n      return;\n    }\n\n    const pos1 = p1.getPosition();\n    const pos2 = p2.getPosition();\n    const pos3 = p3.getPosition();\n    container.canvas.draw(ctx => {\n      if (Utils_1.getDistance(pos1, pos2) > container.retina.linksDistance || Utils_1.getDistance(pos3, pos2) > container.retina.linksDistance || Utils_1.getDistance(pos3, pos1) > container.retina.linksDistance) {\n        return;\n      }\n\n      let colorTriangle = Utils_1.colorToRgb(triangleOptions.color);\n\n      if (!colorTriangle) {\n        const linksOptions = p1.options.links;\n        const linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n        colorTriangle = Utils_1.getLinkColor(p1, p2, linkColor);\n      }\n\n      if (!colorTriangle) {\n        return;\n      }\n\n      Utils_1.drawLinkTriangle(ctx, pos1, pos2, pos3, options.backgroundMask.enable, options.backgroundMask.composite, colorTriangle, opacityTriangle);\n    });\n  }\n\n  drawLinkLine(p1, link) {\n    const container = this.container;\n    const options = container.actualOptions;\n    const p2 = link.destination;\n    let opacity = link.opacity;\n    const pos1 = p1.getPosition();\n    const pos2 = p2.getPosition();\n    container.canvas.draw(ctx => {\n      var _a, _b;\n\n      let colorLine;\n      const twinkle = p1.options.twinkle.lines;\n\n      if (twinkle.enable) {\n        const twinkleFreq = twinkle.frequency;\n        const twinkleRgb = Utils_1.colorToRgb(twinkle.color);\n        const twinkling = Math.random() < twinkleFreq;\n\n        if (twinkling && twinkleRgb !== undefined) {\n          colorLine = twinkleRgb;\n          opacity = twinkle.opacity;\n        }\n      }\n\n      if (!colorLine) {\n        const linksOptions = p1.options.links;\n        const linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n        colorLine = Utils_1.getLinkColor(p1, p2, linkColor);\n      }\n\n      if (!colorLine) {\n        return;\n      }\n\n      const width = (_a = p1.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth;\n      const maxDistance = (_b = p1.linksDistance) !== null && _b !== void 0 ? _b : container.retina.linksDistance;\n      Utils_1.drawLinkLine(ctx, width, pos1, pos2, maxDistance, container.canvas.size, p1.options.links.warp, options.backgroundMask.enable, options.backgroundMask.composite, colorLine, opacity, p1.options.links.shadow);\n    });\n  }\n\n}\n\nexports.LinkInstance = LinkInstance;","map":null,"metadata":{},"sourceType":"script"}